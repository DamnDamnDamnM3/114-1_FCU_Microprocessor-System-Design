# Lab 8 - 數字競賽遊戲與打磚塊遊戲

## 📋 實驗概述

Lab 8 包含兩個子實驗，分別實作數字競賽遊戲和打磚塊遊戲。這些實驗整合了LCD顯示、外部中斷、ADC類比輸入、2D繪圖、按鍵控制和LED指示，展示了嵌入式系統中的遊戲開發和硬體整合技術。

## 🔧 硬體環境

- **微控制器**: NUC100系列
- **開發板**: Nu-LB-NUC140開發板
- **主要週邊**: LCD顯示器（128x64）、LED陣列（PC12-15）、外部中斷按鈕（PB15）、ADC可變電阻（PA7）、蜂鳴器（PB11）、3x3按鍵矩陣

## 🔌 硬體連接

### 通用連接
- **PA0,1,2,3,4,5**: 連接至3x3按鍵矩陣
- **PC12,13,14,15**: 連接至4個LED（共陽極，低電位點亮）
- **LCD顯示器**: 128x64像素圖形LCD，透過SPI連接

### Q1 專用連接
- **PB15**: 外部中斷按鈕（下降緣觸發），用於啟動競賽

### Q2 專用連接
- **PA7**: ADC通道7，連接可變電阻（VR1），用於控制擋板位置
- **PB11**: 連接至蜂鳴器（低電位觸發）

### 按鍵矩陣連接
```
按鍵矩陣    →    GPIO腳位
Row 0      →    PA0
Row 1      →    PA1  
Row 2      →    PA2
Col 0      →    PA3
Col 1      →    PA4
Col 2      →    PA5
```

### LED連接
```
LED編號    →    GPIO腳位    功能
LED1       →    PC12       競賽獲勝者指示器0
LED2       →    PC13       競賽獲勝者指示器1
LED3       →    PC14       競賽獲勝者指示器2
LED4       →    PC15       競賽獲勝者指示器3
```

## 📁 程式檔案說明

### Q1.c - 數字競賽遊戲

**功能**: 實作4個數字從左向右移動的競賽遊戲，速度根據數字大小分配，第一個到達終點的數字觸發對應LED

**系統特點**:
- 自動產生4個不重複的1-9隨機數字
- 數字大小決定移動速度（大數字速度快）
- 使用外部中斷按鈕啟動競賽
- 第一個到達終點的數字觸發LED指示
- 到達終點後等待按鍵繼續下一輪

**遊戲流程**:
```
產生隨機數字 → 顯示初始位置 → 等待外部中斷按鈕 → 開始移動
    ↓
數字依速度移動 → 到達終點檢測 → 第一個到達者觸發LED
    ↓
所有數字到達 → 等待按鍵 → 重新開始
```

**速度分配規則**:
- 將4個數字由大到小排序
- 最大數字：速度 = 8 像素/次
- 第二大數字：速度 = 6 像素/次
- 第三大數字：速度 = 4 像素/次
- 最小數字：速度 = 2 像素/次

**顯示參數**:
- **LCD尺寸**: 128x64像素
- **數字字型**: 5x7像素字元（使用`printC_5x7`函數）
- **Y座標分配**: 每個數字佔用16像素高度（0, 16, 32, 48）
- **起始位置**: X = 0（最左側）
- **終點位置**: X = 122（128 - 6，考慮字元寬度）

**外部中斷設定**:
- **觸發方式**: 下降緣觸發（Falling Edge）
- **防彈跳**: 啟用防彈跳功能，使用LIRC時鐘源，64個時鐘週期
- **中斷處理**: 設定`start_flag`旗標啟動競賽

**LED指示**:
- 只有第一個到達終點的數字會觸發LED
- LED編號對應數字索引（0-3）
- 使用共陽極LED，低電位點亮

### Q1_LanceVer.c - 數字競賽遊戲（Lance版本）

**功能**: 與Q1.c功能相同，但使用不同的顯示函數

**差異說明**:
- 使用`printC`函數（8x16像素字元）而非`printC_5x7`
- 終點位置調整為120（128 - 8，考慮字元寬度）
- 其他遊戲機制相同

### Q2.c - 打磚塊遊戲

**功能**: 實作經典打磚塊遊戲，使用ADC可變電阻控制擋板，球體反彈碰撞障礙物

**系統特點**:
- 使用ADC可變電阻控制擋板水平位置
- 球體自動移動並反彈邊界
- 碰撞擋板時反彈並發出蜂鳴器聲響
- 碰撞障礙物時反彈
- 球體掉落底部時遊戲結束
- 支援按鍵重新開始遊戲

**遊戲狀態機**:
```
STATE_INIT ──[按鍵]──> STATE_PLAYING ──[球掉落]──> STATE_GAMEOVER
    ↑                                                      ↓
    └──────────────────[按鍵]──────────────────────────────┘
```

**遊戲物件參數**:
- **球體尺寸**: 8x8像素
- **擋板尺寸**: 16x8像素
- **障礙物尺寸**: 16x8像素
- **LCD尺寸**: 128x64像素
- **球體初始位置**: 螢幕中央（(128-8)/2, (64-8)/2）
- **擋板初始位置**: 螢幕底部中央（X=56, Y=56）
- **障礙物位置**: 螢幕上方中央（X=56, Y=8）

**ADC設定**:
- **通道**: ADC通道7（PA7）
- **解析度**: 12位元（0-4095）
- **取樣方式**: 8次取樣平均，提高穩定性
- **映射範圍**: ADC值（0-4095）映射到擋板X座標（0-112）

**球體運動**:
- **初始速度**: 4像素/次（隨機方向）
- **移動方向**: 隨機選擇上下左右四個方向之一
- **邊界反彈**: 碰到左右和上邊界時反彈
- **底部檢測**: 球體Y座標達到底部時遊戲結束

**碰撞檢測**:
- 使用AABB（軸對齊邊界框）碰撞檢測
- 檢測球體與擋板的碰撞
- 檢測球體與障礙物的碰撞
- 碰撞時改變球體Y方向速度

**按鍵功能**:
- **任意按鍵**: 在初始狀態時開始遊戲
- **任意按鍵**: 在遊戲結束狀態時重新開始

## 🔍 技術重點

### 1. 外部中斷處理（Q1）
- **中斷設定**: 使用GPIO外部中斷功能
- **防彈跳**: 啟用硬體防彈跳功能
- **中斷服務程式**: 設定旗標而非直接處理，避免長時間中斷
- **中斷清除**: 正確清除中斷旗標和NVIC待處理中斷

### 2. ADC類比輸入（Q2）
- **ADC初始化**: 設定多功能腳位、時鐘源、解析度
- **取樣平均**: 多次取樣取平均，減少雜訊影響
- **數值映射**: 將ADC值映射到實際座標範圍
- **即時更新**: 在主迴圈中持續讀取ADC值更新擋板位置

### 3. 隨機數產生（Q1）
- **不重複數字**: 使用標記陣列確保4個數字不重複
- **排序演算法**: 使用氣泡排序將數字由大到小排序
- **速度分配**: 根據排序結果分配不同速度

### 4. 碰撞檢測（Q2）
- **AABB檢測**: 使用軸對齊邊界框進行碰撞檢測
- **碰撞處理**: 碰撞時改變球體移動方向
- **位置修正**: 碰撞後調整球體位置避免穿透

### 5. 狀態機設計（Q2）
- **狀態定義**: 使用列舉定義遊戲狀態
- **狀態轉換**: 明確的狀態轉換條件
- **狀態處理**: 每個狀態有對應的處理邏輯

### 6. 2D繪圖（Q2）
- **矩形繪製**: 使用`fill_Rectangle`函數繪製遊戲物件
- **畫面清除**: 每次更新前清除整個畫面
- **座標系統**: 使用左上角為原點的座標系統

## 🏗️ 程式架構

### Q1.c 架構
```
主程式迴圈
├── 產生隨機數字
├── 分配速度（根據數字大小）
├── 顯示初始位置
├── 等待外部中斷（start_flag）
└── 移動迴圈
    ├── 更新每個數字位置
    ├── 終點檢測
    ├── 第一個到達者觸發LED
    ├── 所有到達檢測
    ├── 畫面更新
    └── 延遲控制
```

### Q2.c 架構
```
主程式迴圈
├── 狀態機處理
│   ├── STATE_INIT: 初始化遊戲資料，等待按鍵
│   ├── STATE_PLAYING: 遊戲進行中
│   │   ├── 讀取ADC更新擋板位置
│   │   ├── 更新球體位置
│   │   ├── 邊界碰撞檢測
│   │   ├── 擋板碰撞檢測
│   │   ├── 障礙物碰撞檢測
│   │   ├── 底部檢測（遊戲結束）
│   │   └── 畫面更新
│   └── STATE_GAMEOVER: 顯示遊戲結束，等待按鍵
└── 延遲控制
```

### 初始化流程
```c
// Q1 初始化
SYS_Init();              // 系統初始化
init_LCD();              // LCD初始化
clear_LCD();             // 清除螢幕
OpenKeyPad();            // 按鍵初始化
init_LED();              // LED初始化
init_EINT1();            // 外部中斷初始化
srand(1234);             // 隨機數種子

// Q2 初始化
SYS_Init();              // 系統初始化
init_LCD();              // LCD初始化
clear_LCD();             // 清除螢幕
OpenKeyPad();            // 按鍵初始化
Init_ADC();              // ADC初始化（設定多功能腳位）
GPIO_SetMode(PB, BIT11, GPIO_MODE_OUTPUT);  // 蜂鳴器初始化
srand(123);              // 隨機數種子
```

## 🎯 學習目標

1. **外部中斷處理**: 學習GPIO外部中斷的設定和使用
2. **ADC類比輸入**: 掌握ADC的初始化和讀取方法
3. **遊戲狀態機**: 理解狀態機設計在遊戲開發中的應用
4. **碰撞檢測**: 學習AABB碰撞檢測演算法的實作
5. **隨機數產生**: 了解不重複隨機數產生的方法
6. **2D繪圖**: 掌握LCD圖形繪製技術
7. **硬體整合**: 整合多種硬體元件建立完整遊戲系統
8. **即時控制**: 學習即時輸入處理和畫面更新

## 🚀 擴展應用

### Q1 擴展
- 增加更多數字參賽者
- 添加不同難度等級（不同速度範圍）
- 增加分數系統（猜測獲勝者得分）
- 添加音效回饋
- 實作歷史記錄功能
- 增加障礙物或特殊效果

### Q2 擴展
- 增加多個障礙物
- 添加分數系統（擊中障礙物得分）
- 增加關卡系統（難度遞增）
- 添加特殊障礙物（不同分數）
- 實作球體速度變化
- 增加生命值系統
- 添加遊戲時間限制
- 實作高分記錄功能
- 增加多種球體類型

### 硬體擴展
- 整合觸控螢幕控制
- 添加搖桿輸入
- 整合更多LED效果
- 增加音效系統
- 實作無線通訊對戰模式

## ⚠️ 注意事項

1. **硬體連接**: 確保LCD、按鍵矩陣、LED、外部中斷按鈕、ADC和蜂鳴器正確連接
2. **外部中斷**: 注意中斷服務程式的執行時間，避免長時間處理
3. **ADC取樣**: 使用多次取樣平均可提高穩定性
4. **座標系統**: 注意LCD座標系統（左上角為原點）
5. **碰撞檢測**: AABB檢測是簡化方法，適合矩形物件
6. **畫面更新**: 注意繪圖順序，避免畫面殘影
7. **隨機性**: 確保隨機數種子有足夠變化性
8. **邊界處理**: 確保遊戲物件不會超出螢幕範圍
9. **狀態管理**: 正確管理遊戲狀態，避免狀態混亂
10. **LED控制**: 注意LED為共陽極，低電位點亮

## 📚 相關技術

- **GPIO控制**: 數位I/O腳位設定和控制（LED、外部中斷）
- **外部中斷**: GPIO外部中斷的設定和處理
- **ADC轉換**: 類比數位轉換器的使用
- **LCD驅動**: LCD顯示器的初始化和控制
- **繪圖API**: 2D繪圖函數的使用（矩形、字元）
- **定時器**: 延遲和時序控制（`CLK_SysTickDelay`）
- **按鍵掃描**: 按鍵矩陣的掃描和處理
- **數學運算**: 座標計算、碰撞檢測、數值映射
- **演算法**: 隨機數產生、排序、碰撞檢測、狀態機

## 📊 效能考量

- **中斷處理**: 外部中斷服務程式應盡量簡短
- **ADC讀取**: 多次取樣會增加處理時間，但提高穩定性
- **繪圖效能**: 每次更新需要清除和重繪，注意繪圖開銷
- **碰撞檢測**: AABB檢測效率高，適合即時應用
- **CPU使用率**: 適當的延遲控制可降低CPU使用率
- **記憶體使用**: 使用適當的變數類型節省記憶體
