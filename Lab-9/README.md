# Lab 9 - 貪食蛇遊戲系統

## 📋 實驗概述

Lab 9 實作經典的貪食蛇遊戲，使用搖桿（ADC）控制蛇的移動方向，整合LCD顯示、七段顯示器、按鍵控制和遊戲邏輯，展示了嵌入式系統中的完整遊戲開發技術。

## 🔧 硬體環境

- **微控制器**: NUC100系列
- **開發板**: Nu-LB-NUC140開發板
- **主要週邊**: LCD顯示器（128x64）、七段顯示器（4位數）、搖桿（ADC輸入）、重置按鈕（PC0）、3x3按鍵矩陣

## 🔌 硬體連接

### 通用連接
- **PA0,1,2,3,4,5**: 連接至3x3按鍵矩陣
- **LCD顯示器**: 128x64像素圖形LCD，透過SPI連接
- **PC0**: 重置按鈕（Quasi模式，低電位觸發）

### ADC搖桿連接
- **PA0**: ADC通道0，搖桿X軸輸入
- **PA1**: ADC通道1，搖桿Y軸輸入
- **ADC解析度**: 12位元（0-4095）
- **中心值**: 2048（搖桿在中間位置）

### 七段顯示器連接
- **PC4,5,6,7**: 七段顯示器位選（Digit Select）
- **PE0-7**: 七段顯示器段選（Segment Select）

### SPI連接（LCD）
- **PD8**: SPI3_SS0（LCD片選）
- **PD9**: SPI3_CLK（LCD時鐘）
- **PD11**: SPI3_MOSI0（LCD資料）

## 📁 程式檔案說明

### Q1.c - 基礎貪食蛇遊戲

**功能**: 實作固定長度16的貪食蛇遊戲，使用搖桿控制移動方向

**系統特點**:
- 固定蛇身長度16格
- 使用搖桿控制移動方向
- 邊界碰撞檢測
- 自身碰撞檢測
- 使用PC0按鈕重置遊戲
- 遊戲結束時停止移動

**遊戲參數**:
- **蛇身長度**: 固定16格
- **格子尺寸**: 2x2像素（64x32格子）
- **初始位置**: 螢幕中央水平排列
- **初始方向**: 向右
- **移動速度**: 每200ms移動一次

**搖桿控制**:
- **休止區域**: 距離中心700以內視為停止
- **方向判斷**: 比較X和Y軸偏移量，較大者決定方向
- **反向限制**: 禁止直接反向移動（防止意外死亡）

**碰撞檢測**:
- **邊界檢測**: 檢查蛇頭是否超出螢幕範圍
- **自身碰撞**: 檢查蛇頭是否與身體重疊
- **碰撞處理**: 設定遊戲結束旗標，停止移動

**顯示方式**:
- 使用2x2像素方塊表示蛇身
- 每次移動清除尾部，繪製新頭部
- 重繪整條蛇避免殘影

### Q2.c - 完整貪食蛇遊戲（吃水果版本）

**功能**: 實作可吃水果增長的貪食蛇遊戲，包含分數系統和七段顯示器顯示

**系統特點**:
- 動態蛇身長度（初始16，最大100）
- 水果生成系統（隨機位置，不與蛇身重疊）
- 分數系統（吃一個水果+10分）
- 七段顯示器顯示分數
- 使用軟體掃描方式更新七段顯示器

**遊戲參數**:
- **最大蛇身長度**: 100格
- **初始蛇身長度**: 16格
- **格子尺寸**: 2x2像素（64x32格子）
- **分數增量**: 每吃一個水果+10分
- **移動速度**: 每200ms移動一次

**水果系統**:
- **生成位置**: 隨機生成在64x32格子範圍內
- **碰撞檢測**: 確保水果不與蛇身重疊
- **種子來源**: 使用ADC值和分數作為隨機數種子
- **顯示方式**: 使用2x2像素白色方塊表示

**分數顯示**:
- **顯示方式**: 使用七段顯示器顯示4位數分數
- **掃描方式**: 在延遲函數中進行軟體掃描
- **掃描頻率**: 每個位數顯示1ms，總週期4ms（250Hz）
- **動態顯示**: 根據分數大小動態顯示有效位數

**遊戲流程**:
```
初始化 → 生成水果 → 搖桿控制 → 移動蛇身
    ↓
碰撞檢測 → 吃到水果 → 增長蛇身 + 分數 + 新水果
    ↓
邊界/自身碰撞 → 遊戲結束 → 等待重置
```

### Q2-final.c - 完整貪食蛇遊戲（Timer中斷版本）

**功能**: 與Q2.c功能相同，但使用Timer0中斷處理七段顯示器掃描

**改進特點**:
- 使用Timer0硬體中斷處理七段顯示器掃描
- 解決軟體掃描造成的閃爍問題
- 更穩定的顯示效果
- 主程式迴圈更簡潔

**Timer0設定**:
- **時鐘源**: HXT（12MHz）
- **預除頻器**: 11（Prescaler）
- **比較值**: 2500
- **中斷頻率**: 400Hz（每2.5ms中斷一次）
- **掃描方式**: 輪流掃描4個位數

**中斷處理**:
- 清除Timer0中斷旗標
- 關閉所有七段顯示器（消影）
- 顯示當前位數的數值
- 更新掃描索引

**顯示緩衝區**:
- 使用全域陣列`g_DisplayBuf[4]`儲存4個位數的值
- 值為-1表示該位數不顯示
- 主程式更新分數時同步更新緩衝區

## 🔍 技術重點

### 1. ADC搖桿輸入
- **雙通道ADC**: 同時讀取X和Y軸ADC值
- **中斷驅動**: 使用ADC中斷自動更新數值
- **休止區域**: 設定閾值避免微小震動造成誤動作
- **方向計算**: 使用距離平方判斷，避免開平方運算

### 2. 遊戲邏輯
- **蛇身管理**: 使用陣列儲存蛇身座標
- **移動機制**: 尾部清除，頭部新增
- **增長機制**: 吃到水果時不清除尾部
- **碰撞檢測**: 邊界和自身碰撞檢測

### 3. 隨機數產生
- **水果位置**: 使用隨機數生成水果位置
- **種子來源**: 結合ADC值和分數作為種子
- **碰撞避免**: 確保水果不與蛇身重疊

### 4. 七段顯示器控制
- **多工掃描**: 快速輪流顯示4個位數
- **消影處理**: 切換位數前先關閉所有顯示
- **動態顯示**: 根據數值大小動態顯示有效位數
- **中斷掃描**: 使用Timer中斷實現穩定掃描

### 5. 座標系統
- **格子座標**: 使用64x32格子座標系統
- **像素轉換**: 格子座標乘以2轉換為像素座標
- **邊界檢查**: 在格子座標系統中進行邊界檢查

### 6. 狀態管理
- **遊戲狀態**: 追蹤遊戲進行/結束狀態
- **方向管理**: 當前方向和下一個方向分開管理
- **重置機制**: 按鈕重置遊戲狀態

## 🏗️ 程式架構

### Q1.c 架構
```
主程式迴圈
├── 重置按鈕檢測
├── 遊戲結束處理
├── 搖桿邏輯更新
└── 移動處理（如果方向不為STOP）
    ├── 計算新頭部位置
    ├── 邊界檢測
    ├── 自身碰撞檢測
    ├── 清除尾部
    ├── 蛇身前移
    ├── 新增頭部
    ├── 繪製蛇身
    └── 延遲控制
```

### Q2.c / Q2-final.c 架構
```
主程式迴圈
├── 重置按鈕檢測
├── 遊戲結束處理
├── 搖桿邏輯更新
└── 移動處理（如果方向不為STOP）
    ├── 計算新頭部位置
    ├── 邊界檢測
    ├── 自身碰撞檢測
    ├── 水果碰撞檢測
    │   ├── 吃到水果：增長、加分、新水果
    │   └── 未吃到：正常移動（清除尾部）
    ├── 更新蛇身
    ├── 繪製蛇身和水果
    └── 延遲控制（Q2）或直接延遲（Q2-final）
```

### 初始化流程
```c
SYS_Init();              // 系統初始化
SYS_UnlockReg();         // 解鎖暫存器
// 設定時鐘和多功能腳位
CLK->APBCLK |= (1 << 15) | (1 << 28);  // SPI3和ADC時鐘
SYS->GPD_MFP |= ...;     // SPI3多功能腳位
SYS->GPA_MFP |= ...;     // ADC多功能腳位
SYS_LockReg();           // 鎖定暫存器

// LCD重置序列
GPIO_SetMode(PD, BIT12 | BIT14, GPIO_MODE_OUTPUT);
// ... LCD重置流程 ...

Init_ADC();              // ADC初始化
init_LCD();              // LCD初始化
clear_LCD();             // 清除螢幕
OpenSevenSegment();      // 七段顯示器初始化（Q2）
Init_Timer0_For_Scan();  // Timer0初始化（Q2-final）
GPIO_SetMode(PC, BIT0, GPIO_MODE_QUASI);  // 重置按鈕

init_Snake();            // 初始化蛇（Q1）
或
init_Game();             // 初始化遊戲（Q2）
```

## 🎯 學習目標

1. **ADC多通道輸入**: 學習同時讀取多個ADC通道
2. **搖桿控制**: 掌握搖桿輸入的處理和方向判斷
3. **遊戲邏輯設計**: 理解遊戲狀態管理和物件管理
4. **碰撞檢測**: 學習多種碰撞檢測方法（邊界、自身、物件）
5. **動態資料結構**: 學習動態長度陣列的管理
6. **七段顯示器**: 掌握多工掃描和動態顯示技術
7. **Timer中斷**: 學習使用Timer中斷處理週期性任務
8. **系統整合**: 整合多種硬體元件建立完整遊戲系統

## 🚀 擴展應用

### 遊戲功能擴展
- 增加多種水果類型（不同分數）
- 添加障礙物系統
- 增加關卡系統（難度遞增）
- 添加特殊效果（加速、減速、縮短）
- 實作遊戲時間限制
- 增加生命值系統
- 實作高分記錄功能
- 添加遊戲暫停功能

### 顯示擴展
- 增加遊戲開始/結束畫面
- 添加分數動畫效果
- 增加遊戲統計資訊
- 實作選單系統

### 控制擴展
- 整合觸控螢幕控制
- 添加按鍵控制選項
- 增加手勢識別

### 硬體擴展
- 整合更多LED效果
- 增加音效系統
- 實作無線通訊對戰模式
- 添加震動回饋

## ⚠️ 注意事項

1. **硬體連接**: 確保LCD、七段顯示器、ADC搖桿和重置按鈕正確連接
2. **ADC讀取**: ADC值會在中斷中自動更新，無需在主迴圈中讀取
3. **搖桿休止區域**: 適當設定閾值避免微小震動
4. **反向限制**: 禁止直接反向可防止意外死亡
5. **座標系統**: 注意格子座標和像素座標的轉換
6. **碰撞檢測**: 確保碰撞檢測邏輯正確，避免穿透
7. **七段顯示器掃描**: 掃描頻率要足夠高避免閃爍
8. **Timer中斷**: 中斷服務程式應盡量簡短
9. **記憶體使用**: 注意蛇身陣列大小，避免溢出
10. **重置按鈕**: 使用Quasi模式避免浮接造成誤觸發

## 📚 相關技術

- **ADC轉換**: 多通道ADC的設定和使用
- **中斷處理**: ADC中斷和Timer中斷的處理
- **GPIO控制**: 數位I/O腳位設定和控制
- **LCD驅動**: LCD顯示器的初始化和控制
- **繪圖API**: 像素繪製函數的使用
- **七段顯示器**: 多工掃描和動態顯示
- **定時器**: Timer0的設定和中斷處理
- **數學運算**: 座標計算、距離計算、碰撞檢測
- **演算法**: 隨機數產生、碰撞檢測、遊戲邏輯

## 📊 效能考量

- **ADC中斷**: 中斷頻率適中，不影響主程式執行
- **Timer中斷**: 400Hz中斷頻率適合七段顯示器掃描
- **繪圖效能**: 每次移動需要清除和重繪，注意繪圖開銷
- **碰撞檢測**: 線性搜尋效率與蛇身長度相關
- **CPU使用率**: 適當的延遲控制可降低CPU使用率
- **記憶體使用**: 蛇身陣列大小影響記憶體使用

## 🔄 版本差異

### Q1 vs Q2
- **蛇身長度**: Q1固定16，Q2動態增長
- **水果系統**: Q1無，Q2有
- **分數系統**: Q1無，Q2有
- **顯示器**: Q1無七段顯示器，Q2有

### Q2 vs Q2-final
- **七段顯示器掃描**: Q2軟體掃描，Q2-final硬體中斷掃描
- **顯示穩定性**: Q2-final更穩定，無閃爍
- **程式複雜度**: Q2-final主程式更簡潔
- **中斷使用**: Q2-final使用Timer0中斷

